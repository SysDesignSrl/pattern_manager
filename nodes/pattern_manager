#!/usr/bin/env python

# Copyright 2019 Danish Technological Institute (DTI)

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: Mikkel Rath Hansen

# python
import logging
from pattern_manager.collection import GType, Group, Manager
from pattern_manager.patterns import PatternFactory
# ROS
import rospy
from tf2_ros import TransformBroadcaster
import visualization_msgs.msg as viz_msg
from std_srvs.srv import Trigger, TriggerResponse, TriggerRequest
import geometry_msgs.msg as gm
import pattern_manager.srv as pm_srv

from pluginlib import PluginLoader


class PatternManagerNode(object):

    def __init__(self):
        rospy.logwarn("Loading example patterns to demonstrate node and concepts")

        # Register pattern plugin classes with pattern factory
        _ld = PluginLoader(group='patterns')
        for k in _ld.plugins['pattern'].keys():
            PatternFactory.reg_pattern_typ(k, _ld.get_plugin('pattern', k))

        # Make a root group to contain all subsequent groups
        self.g_root = Group(GType.GOG, "root")
        Manager.set_active(id(self.g_root), True)

        # Create and add subgroups to root group
        g1 = Group(GType.GOP, "g1", self.g_root)
        g2 = Group(GType.GOG, "g2", self.g_root)

        import pattern_manager.examples as ex

        # Create and add patterns to group 1 and group 2
        ds = [ex.linear_d, ex.rect_d, ex.scatter_d, ex.circle_d]
        self.patterns = []
        for i in range(len(ds)):
            p = PatternFactory.mk_pattern(
                ds[i]['pattern_type'],
                ds[i]['base_params'],
                ds[i]['pattern_params'])

            self.patterns.append(p)

            grp = g1 if i < 2 else g2
            grp.add_child(p)
        
        Manager.set_active_group(g1)

        print "Active elements:"
        Manager.print_active_subs(self.g_root)

        # services
        self._iter_srv = rospy.Service('~iterate', Trigger, self.cb_iterate)
        self._finished_srv = rospy.Service('~is_finished', pm_srv.ElementName, self.cb_finished)
        self._set_active_srv = rospy.Service('~set_active', pm_srv.ElementName, self.cb_set_active)
        self._get_iterator_srv = rospy.Service('~get_iterator', pm_srv.ElementIterator, self.cb_get_iterator)
        self._reset_srv = rospy.Service('~reset', pm_srv.ElementName, self.cb_reset)
        #self._get_groups_srv = rospy.Service('~get_all_groups', pm_srv.GroupIndex, self.cb_finished)

        # publishers
        self._marker_pub = rospy.Publisher('~pattern_markers', viz_msg.MarkerArray, queue_size=10)
        self._tb = TransformBroadcaster()

        self.actv_pat = Manager.get_active_pattern(self.g_root)

    # SERVICE CALLBACKS

    def cb_iterate(self, req):
        rospy.logdebug("Received iterate request")
        resp = TriggerResponse()
        
        ok = Manager.iterate(self.actv_pat)
        if not ok:
            self.actv_pat = Manager.get_active_pattern(self.g_root)
        
        if self.actv_pat:
            resp.message = "Active pattern: {}".format(self.actv_pat.nm)
            resp.message += " -> i: {}".format(Manager.i[id(self.actv_pat)])        
            resp.success = True
        else:
            resp.message = "Iteration is done!"
            resp.success = False

        return resp

    def cb_finished(self, req):
        rospy.logdebug("Requesting finished status of element: '{}'".format(req.element_name))

        e = Group.get_sub_by_name(req.element_name, self.g_root)
        if e:
            return e.finished
        else:
            rospy.logwarn("Element with name '{}' does not exist".format(req.element_name))

            return False

    def cb_set_active(self, req):
        rospy.logdebug("Setting active group: '{}'".format(req.element_name))

        e = Group.get_sub_by_name(req.element_name, self.g_root)
        if e:
            Manager.set_active_subs(self.g_root, False)
            Manager.set_active_group(e)

            return True
        else:
            rospy.logerr("Group with name '{}' does not exist".format(req.element_name))

            return False
    
    def cb_get_iterator(self, req):
        rospy.logdebug("Getting iterator of element: '{}'".format(req.element_name))

        resp = pm_srv.ElementIteratorResponse()

        e = Group.get_sub_by_name(req.element_name, self.g_root)
        resp.success = True if e else False

        if e:
            resp.iterator = Manager.i[id(e)]
        else:
            rospy.logwarn("Element with name '{}' does not exist".format(req.element_name))

        return resp

    def cb_reset(self, req):
        rospy.logdebug("Resetting element: '{}'".format(req.element_name))

        e = Group.get_sub_by_name(req.element_name, self.g_root)
        if e:
            Manager.reset_element(e)
            Manager.reset_subs(e)

            return True
        else:
            rospy.logwarn("Element with name '{}' does not exist".format(req.element_name))

            return False
        
    # PUBLISHERS

    def pub_current_tf(self):
        p = Manager.get_active_pattern(self.g_root)
        # patterns are flagged inactive if they are finished, this checks if all patterns in a group are finished
        if not p or not p.typ == "Pattern":
            rospy.logwarn_throttle(2.0, "No active active pattern available")
            
            return

        tf = p.tfs[Manager.i[id(p)]]

        # TODO: This fails if the returned current element is not a Pattern

        if not tf:
            return

        frame = p.ref_frame_id

        t = gm.TransformStamped()
        t.header.frame_id = frame
        t.header.stamp = rospy.Time.now()
        t.child_frame_id = "pattern_current"
        t.transform = tf

        self._tb.sendTransform(t)

    def pub_markers(self):
        ma = viz_msg.MarkerArray()
        now = rospy.Time.now()
        
        # for each pattern
        for p in self.patterns:
            frame = p.ref_frame_id
            size = len(p.tfs)
            alpha = 1.0 if Manager.active[id(p)] else 0.5

            for i in range(size):
                # color
                if Manager.finished[id(p)]:
                    color = 'r'
                elif i < Manager.i[id(p)]:
                    color = 'r'
                elif i == Manager.i[id(p)]:
                    color = 'y'
                else:
                    color = 'g'
                
                # data
                tf = p.tfs[Manager.i[id(p)]]
                ns = p.nm
                m = self.create_marker(frame, now, tf, ns, i, color, alpha)
                ma.markers.append(m)

        self._marker_pub.publish(ma)

    def create_marker(self, frame_id, stamp, transform, ns, uid, color='g', alpha=1.0):
        # color can be g/r/y
        mark = viz_msg.Marker()
        mark.header.frame_id = frame_id
        mark.header.stamp = stamp
        mark.ns = ns
        mark.id = uid
        mark.action = viz_msg.Marker.ADD
        
        # pose
        mark.pose.position.x = transform.translation.x
        mark.pose.position.y = transform.translation.y
        mark.pose.position.z = transform.translation.z
        mark.pose.orientation.x = transform.rotation.x
        mark.pose.orientation.y = transform.rotation.y
        mark.pose.orientation.z = transform.rotation.z
        mark.pose.orientation.w = transform.rotation.w
        
        # appearance - TODO: This should be changeable
        mark.type = viz_msg.Marker.CUBE

        mark.scale.x = 0.02
        mark.scale.y = 0.02
        mark.scale.z = 0.02
        
        if color == 'y':
            mark.color.r = 1.0
            mark.color.g = 1.0
            mark.color.b = 0.0
        elif color == 'r':
            mark.color.r = 1.0
            mark.color.g = 0.0
            mark.color.b = 0.0
        else:  # g
            mark.color.r = 0.0
            mark.color.g = 1.0
            mark.color.b = 0.0

        mark.color.a = alpha
        mark.lifetime = rospy.Duration()

        return mark


if __name__ == "__main__":
    rospy.init_node("pattern_manager", log_level=rospy.DEBUG)
    pmn = PatternManagerNode()
    rospy.loginfo("Pattern manager node started")

    r = rospy.Rate(5)
    while not rospy.is_shutdown():
        pmn.pub_markers()
        pmn.pub_current_tf()
        r.sleep()
