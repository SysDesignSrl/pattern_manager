#!/usr/bin/env python

# Copyright 2019 Danish Technological Institute (DTI)

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: Mikkel Rath Hansen

# python
import logging
# from pattern_manager.manager import Manager
from pattern_manager import Tree
from pattern_manager.patterns import PatternFactory
# ROS
import rospy
from tf2_ros import TransformBroadcaster
import visualization_msgs.msg as viz_msg
from std_srvs.srv import Trigger, TriggerResponse, TriggerRequest
import geometry_msgs.msg as gm
import pattern_manager.srv as pm_srv
import pattern_manager.msg as pm_msg

from pluginlib import PluginLoader


class PatternManagerNode(object):

    def __init__(self):
        rospy.logwarn("Loading example patterns to demonstrate node and concepts")

        # Register pattern plugin classes with pattern factory
        _ld = PluginLoader(group='patterns')
        for k in _ld.plugins['pattern'].keys():
            PatternFactory.reg_pattern_typ(k, _ld.get_plugin('pattern', k))

        # self.nodes = {}

        # Make a root group to contain all subsequent groups
        root = Tree('root')
        t1 = Tree('t1', root)
        t2 = Tree('t2', root)
        t3 = Tree('t3', root)
        t4 = Tree('t4', root)

        # for t in [root, t1, t2, t3, t4]:
        #     self.nodes[id(t)] = t

        import pattern_manager.examples as ex

        # Create and add patterns to group 1 and group 2
        ds = [ex.linear_d, ex.rect_d, ex.box_1, ex.box_2, ex.circle_d, ex.scatter_d]
        # self.patterns = {}
        for i in range(len(ds)):
            p = PatternFactory.mk_pattern(
                ds[i]['pattern_type'],
                ds[i]['base_params'],
                ds[i]['pattern_params'])

            # self.patterns[id(p)] = p

            if i < 2:
                grp = t1
            elif i < 4:
                grp = t2
            else:
                grp = t4

            grp.add_node(p)
        
        for g in [t1, t2]:
            t3.add_node(g)

        # services
        self._get_pattern_types_srv = rospy.Service('~get_pattern_types', pm_srv.PatternTypes, self.cb_get_pattern_types)
        self._create_pattern_srv = rospy.Service('~create_pattern', pm_srv.CreatePattern, self.cb_create_pattern)
        self._create_group_srv = rospy.Service('~create_group', pm_srv.CreateGroup, self.cb_create_group)
        self._get_patterns_srv = rospy.Service('~get_patterns', pm_srv.GroupTree, self.cb_get_patterns)
        self._iter_srv = rospy.Service('~iterate', Trigger, self.cb_iterate)
        # self._finished_srv = rospy.Service('~is_finished', pm_srv.ElementName, self.cb_finished)
        self._set_active_srv = rospy.Service('~set_active', pm_srv.SetActive, self.cb_set_active)
        self._get_iterator_srv = rospy.Service('~get_iterator', pm_srv.ElementIterator, self.cb_get_iterator)
        self._reset_srv = rospy.Service('~reset', pm_srv.NodeId, self.cb_reset)
        self._get_groups_srv = rospy.Service('~get_groups', pm_srv.GroupTree, self.cb_get_groups)
        self._remove_group_srv = rospy.Service('~remove_group', pm_srv.NodeId, self.cb_remove_group)
        self._remove_pattern_srv = rospy.Service('~remove_pattern', pm_srv.NodeId, self.cb_remove_pattern)

        # publishers
        self._marker_pub = rospy.Publisher('~pattern_markers', viz_msg.MarkerArray, queue_size=10)
        self._tb = TransformBroadcaster()

    # SERVICE CALLBACKS

    def cb_remove_group(self, req):
        rospy.logdebug('Received request to remove group %s', req.id)
        resp = pm_srv.NodeIdResponse()

        try:
            n = Tree.get_node(req.id)

            if n.parent:
                del n.parent.children[req.id]

            resp.success = True
        except IndexError, e:
            rospy.logwarn("Could not remove group %s: %s" % (req.id, e))

            resp.success = False

        return resp

    def cb_remove_pattern(self, req):
        rospy.logdebug('Received request to remove pattern %s', req.id)
        resp = pm_srv.NodeIdResponse()

        try:
            n = Tree.get_node(req.id)

            if n.parent:
                del n.parent.children[req.id]

            resp.success = True
        except IndexError, e:
            rospy.logwarn("Could not remove pattern %s: %s" % (req.id, e))

            resp.success = False

        return resp

    def cb_get_pattern_types(self, req):
        rospy.logdebug("Recieved request to retrieve all pattern types")
        resp = pm_srv.PatternTypesResponse()
        resp.pattern_types = list(PatternFactory.pattern_typs.keys())

        return resp

    def cb_get_patterns(self, req):
        rospy.logdebug("Recieved request to retrieve all patterns")

        resp = pm_srv.GroupTreeResponse()

        p_list = []
        for p in self.patterns.values():
            pd = pm_msg.GroupDeps()
            pd.name_and_parent = [p.name, p.name]
            pd.type = 'Pattern'
            pd.id = id(p)

            if p.parent:
                pd.name_and_parent[1] = p.parent.name

            p_list.append(pd)

        resp.group_deps = p_list
        resp.success = True

        return resp

    def cb_get_groups(self, req):
        rospy.logdebug("Received request to retrieve all groups")
        resp = pm_srv.GroupTreeResponse()

        g_list = []
        for g in self.nodes.values():
            gd = pm_msg.GroupDeps()
            gd.name_and_parent = [g.name, g.name]
            gd.type = 'Group'
            gd.id = id(g)

            if g.parent:
                gd.name_and_parent[1] = g.parent.name

            g_list.append(gd)

        resp.group_deps = g_list
        resp.success = True

        return resp

    def cb_create_pattern(self, req):
        rospy.logdebug("Received create pattern request")
        resp = pm_srv.CreatePatternResponse()

        if not req.pat_name:
            rospy.logwarn("Pattern must have a name!")
            resp.success = False

            return resp

        try:
            pat = PatternFactory.mk_pattern(req.pat_type, {"nm": req.pat_name}, {})
            self.patterns[id(pat)] = pat
            self.nodes[req.parent_id].add_node(pat)

            resp.success = True
            rospy.logout("Pattern {} successfully created!".format(req.pat_name))
        except IndexError, e:
            rospy.logwarn("Could not create pattern of type %s: %s" % (req.pat_type, e))
            resp.success = False

        return resp

    def cb_create_group(self, req):
        rospy.logdebug("Received create group request")
        resp = pm_srv.CreateGroupResponse()

        if not req.group_name:
            rospy.logwarn("Group must have a name!")
            resp.success = False

            return resp

        try:
            grp = Tree(req.group_name, self.nodes[req.parent_id])
            self.nodes[id(grp)] = grp

            resp.success = True
            rospy.logout("Group {} successfully created!".format(req.group_name))
        except IndexError, e:
            rospy.logwarn("Could not create group %s: %s" % (req.group_name, e))
            resp.success = False

        return resp

    def cb_iterate(self, req):
        rospy.logdebug("Received iterate request")
        resp = TriggerResponse()

        ok = Tree.root

        if ok:
            resp.message = "Iteration successful"
            resp.success = True
        else:
            resp.message = "Iteration is done!"
            resp.success = False

        return resp

    # def cb_finished(self, req):
    #     rospy.logdebug("Requesting finished status of element: '{}'".format(req.element_name))
    #
    #     e = Group.get_sub_by_name(req.element_name, self.g_root)
    #     if e:
    #         return e.finished
    #     else:
    #         rospy.logwarn("Element with name '{}' does not exist".format(req.element_name))
    #
    #         return False

    def cb_set_active(self, req):
        rospy.logdebug("Setting active group: '{}'".format(req.element_name))
        resp = pm_srv.NodeIdResponse()

        try:
            n = self.nodes[req.id]
            n.set_active(req.active)

            resp.success = True
        except IndexError, e:
            rospy.logerr("Could not set active %s: %s" % (req.id, e))

            resp.success = False

        return resp

    def cb_get_iterator(self, req):
        rospy.logdebug("Getting iterator of element: '{}'".format(req.id))
        resp = pm_srv.ElementIteratorResponse()

        try:
            n = self.nodes[req.id]
            resp.iterator = n.i

            resp.success = True
        except IndexError, e:
            rospy.logerr("Could find iterator for %d: %s" % (req.id, e))

            resp.success = False

        return resp

    def cb_reset(self, req):
        rospy.logdebug("Resetting element: '{}'".format(req.element_name))
        resp = pm_srv.NodeIdResponse()

        try:
            self.nodes[req.id].i = 0
            resp.success = True
        except IndexError, e:
            rospy.logerr("Could find node %d: %s" % (req.id, e))

            resp.success = False

        return resp

    # PUBLISHERS

    # def pub_current_tf(self):
    #     p = Manager.get_active_pattern(self.g_root)
    #     # patterns are flagged inactive if they are finished, this checks if all patterns in a group are finished
    #     if not p or not p.typ == "Pattern":
    #         rospy.logwarn_throttle(2.0, "No active pattern available")
    #
    #         return
    #
    #     tf = p.tfs[Manager.i[id(p)]]
    #
    #     # TODO: This fails if the returned current element is not a Pattern
    #
    #     if not tf:
    #         return
    #
    #     frame = p.ref_frame_id
    #
    #     t = gm.TransformStamped()
    #     t.header.frame_id = frame
    #     t.header.stamp = rospy.Time.now()
    #     t.child_frame_id = "pattern_current"
    #     t.transform = tf
    #
    #     self._tb.sendTransform(t)
    #
    # def pub_markers(self):
    #     ma = viz_msg.MarkerArray()
    #     now = rospy.Time.now()
    #
    #     # for each pattern
    #     for p in self.patterns.values():
    #         frame = p.ref_frame_id
    #         size = len(p.tfs)
    #         #print size
    #         alpha = 1.0 if Manager.active[id(p)] else 0.4
    #
    #         for i in range(size):
    #             # color
    #             if Manager.finished[id(p)]:
    #                 color = 'r'
    #             elif i < Manager.i[id(p)]:
    #                 color = 'r'
    #             elif i == Manager.i[id(p)]:
    #                 color = 'y'
    #             else:
    #                 color = 'g'
    #
    #             # data
    #             tf = p.tfs[i]
    #             #print tf
    #             ns = p.name
    #             m = self.create_marker(frame, now, tf, ns, i, color, alpha)
    #             ma.markers.append(m)
    #
    #     self._marker_pub.publish(ma)
    #
    # def create_marker(self, frame_id, stamp, transform, ns, uid, color='g', alpha=1.0):
    #     # color can be g/r/y
    #     mark = viz_msg.Marker()
    #     mark.header.frame_id = frame_id
    #     mark.header.stamp = stamp
    #     mark.ns = ns
    #     mark.id = uid
    #     mark.action = viz_msg.Marker.ADD
    #
    #     # pose
    #     mark.pose.position.x = transform.translation.x
    #     mark.pose.position.y = transform.translation.y
    #     mark.pose.position.z = transform.translation.z
    #     mark.pose.orientation.x = transform.rotation.x
    #     mark.pose.orientation.y = transform.rotation.y
    #     mark.pose.orientation.z = transform.rotation.z
    #     mark.pose.orientation.w = transform.rotation.w
    #
    #     # appearance - TODO: This should be changeable
    #     mark.type = viz_msg.Marker.CUBE
    #
    #     mark.scale.x = 0.025
    #     mark.scale.y = 0.025
    #     mark.scale.z = 0.025
    #
    #     if color == 'y':
    #         mark.color.r = 1.0
    #         mark.color.g = 1.0
    #         mark.color.b = 0.0
    #     elif color == 'r':
    #         mark.color.r = 1.0
    #         mark.color.g = 0.0
    #         mark.color.b = 0.0
    #     else:  # g
    #         mark.color.r = 0.0
    #         mark.color.g = 1.0
    #         mark.color.b = 0.0
    #
    #     mark.color.a = alpha
    #     mark.lifetime = rospy.Duration()
    #
    #     return mark


if __name__ == "__main__":
    rospy.init_node("pattern_manager", log_level=rospy.DEBUG)
    pmn = PatternManagerNode()
    rospy.loginfo("Pattern manager node started")

    r = rospy.Rate(5)
    while not rospy.is_shutdown():
        # pmn.pub_markers()
        # pmn.pub_current_tf()
        r.sleep()
