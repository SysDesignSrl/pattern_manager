#!/usr/bin/env python

# Copyright 2019 Danish Technological Institute (DTI)

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: Mikkel Rath Hansen

# python
import logging
# pattern manager
import pattern_manager
# ROS
import rospy
from tf2_ros import TransformBroadcaster
import visualization_msgs.msg as viz_msg
from std_srvs.srv import Trigger, TriggerResponse, TriggerRequest
import geometry_msgs.msg as gm
import pattern_manager.srv as pm_srv


class PatternManagerNode(object):

    def __init__(self, demo_mode=False):
        if demo_mode:
            #TODO: Get rid of this once the configuration and UI is implemented
            rospy.logwarn("Loading example patterns to demonstrate node and concepts")
            import pattern_manager.examples as ex
            ds = [ex.linear_d, ex.linear_d2, ex.rect_d, ex.scatter_d, ex.circle_d]
            self._pmi = pattern_manager.api.API(ds)
            man = self._pmi.manager
            print [e.name for e in man.elements.values()]
            man.group_elements([0, 1], "group_1")
            man.group_elements([2, 3, 4], "group_2")
            man.group_elements([5, 6], "group_3")
            print [e.name for e in man.elements.values()]
            self._pmi.get_element_by_name("group_3").active = True
            self._pmi.get_element_by_name("group_1").active = True
            self._pmi.get_element_by_name("cheese_linear").active = True
        else:
            self._pmi = pattern_manager.api.API()
        self._top_man = self._pmi.manager

        # services
        self._iter_srv = rospy.Service('~iterate', Trigger, self.cb_iterate)
        self._finished_srv = rospy.Service('~is_finished', pm_srv.GroupName, self.cb_finished)
        self._set_active_srv = rospy.Service('~set_active', pm_srv.GroupName, self.cb_set_active)
        self._get_iterator_srv = rospy.Service('~get_iterator', pm_srv.GroupIterator, self.cb_get_iterator)
        self._reset_srv = rospy.Service('~reset', pm_srv.GroupName, self.cb_reset)
        #self._get_groups_srv = rospy.Service('~get_all_groups', pm_srv.GroupIndex, self.cb_finished)

        # publishers
        self._marker_pub = rospy.Publisher('~pattern_markers', viz_msg.MarkerArray, queue_size=10)
        self._tb = TransformBroadcaster()

    # API interface

    def get_all_patterns(self):
        elements = []
        self._pmi.get_elements_from_manager_tree(elements)
        pattern_list = [p for p in elements if isinstance(p, pattern_manager.patterns.Pattern)]
        return pattern_list

    # SERVICE CALLBACKS ###

    def cb_iterate(self, req):
        rospy.logdebug("Received iterate request")
        r = TriggerResponse()
        ok = self._pmi.iterate()
        active_element = self._pmi.get_active_leaf_manager()
        if ok:
            r.success = True
            r.message = "New iterator is {}".format(ok)
        else:
            r.success = False
            r.message = "Element {} is finished".format(active_element.name)
        return r

    def cb_finished(self, req):
        rospy.logdebug("Requesting finished status of group: '{}'".format(req.group_name))
        e = self._pmi.get_element_by_name(req.group_name)
        if e is not None:
            return e.finished
        else:
            rospy.logwarn("Group with name '{}' does not exist".format(req.group_name))
            return False

    def cb_set_active(self, req):
        rospy.logdebug("Setting active group: '{}'".format(req.group_name))
        e = self._pmi.get_element_by_name(req.group_name)
        if e is not None:
            return self._pmi.set_active_manager(e, active=True)
        else:
            rospy.logwarn("Group with name '{}' does not exist".format(req.group_name))
            return False
    
    def cb_get_iterator(self, req):
        rospy.logdebug("Getting iterator of group: '{}'".format(req.group_name))
        resp = pm_srv.GroupIteratorResponse()
        e = self._pmi.get_element_by_name(req.group_name)
        if e is not None:
            resp.iterator = e.iterator
            resp.success = True
        else:
            rospy.logwarn("Group with name '{}' does not exist".format(req.group_name))
            resp.success = False
        return resp

    def cb_reset(self, req):
        rospy.logdebug("Resetting group: '{}'".format(req.group_name))
        e = self._pmi.get_element_by_name(req.group_name)
        if e is not None:
            self._pmi.reset_element_tree(e)
            return True
        else:
            rospy.logwarn("Group with name '{}' does not exist".format(req.group_name))
            return False
        
    ### PUBLISHERS ###

    def pub_current_tf(self):
        man = self._pmi.get_active_manager()
        p = man.active_element[1]
        transf = p.get_current_tf()
        if transf is False:
            return
        frame = p.pattern_frame_id
        t = gm.TransformStamped()
        t.header.frame_id = frame
        t.header.stamp = rospy.Time.now()
        t.child_frame_id = "pattern_current"
        t.transform = transf
        self._tb.sendTransform(t)

    def pub_markers(self):
        ma = viz_msg.MarkerArray()
        now = rospy.Time.now()
        alpha = 1.0 #TODO: Highlight with alpa=1 the current pattern/group
        # for each pattern
        for p in self.get_all_patterns():
            frame = p.pattern_frame_id
            size = p.get_pattern_size()
            for i in range(size):
                # color
                if p.is_finished():
                    color = 'r'
                elif i < p.iterator:
                    color = 'r'
                elif i == p.iterator:
                    color = 'y'
                else:
                    color = 'g'
                # data
                transf = p.get_tf_from_iter(i)
                #ns = "pattern_" + str(pi)
                ns = p.name
                m = self.create_marker(frame, now, transf, ns, i, color, alpha)
                ma.markers.append(m)
        self._marker_pub.publish(ma)

    def create_marker(self, frame_id, stamp, transform, ns, uid, color='g', alpha=1.0):
        # color can be g/r/y
        mark = viz_msg.Marker()
        mark.header.frame_id = frame_id
        mark.header.stamp = stamp
        mark.ns = ns
        mark.id = uid
        mark.action = viz_msg.Marker.ADD
        # pose
        mark.pose.position.x = transform.translation.x
        mark.pose.position.y = transform.translation.y
        mark.pose.position.z = transform.translation.z
        mark.pose.orientation.x = transform.rotation.x
        mark.pose.orientation.y = transform.rotation.y
        mark.pose.orientation.z = transform.rotation.z
        mark.pose.orientation.w = transform.rotation.w
        # appearance - TODO: This should be changeable
        mark.type = viz_msg.Marker.CUBE
        mark.scale.x = 0.02
        mark.scale.y = 0.02
        mark.scale.z = 0.02
        if color == 'y':
            mark.color.r = 1.0
            mark.color.g = 1.0
            mark.color.b = 0.0
        elif color == 'r':
            mark.color.r = 1.0
            mark.color.g = 0.0
            mark.color.b = 0.0
        else:  # g
            mark.color.r = 0.0
            mark.color.g = 1.0
            mark.color.b = 0.0
        mark.color.a = alpha
        mark.lifetime = rospy.Duration()
        return mark


if __name__ == "__main__":
    rospy.init_node("pattern_manager", log_level=rospy.DEBUG)
    pmn = PatternManagerNode(demo_mode=True)
    rospy.loginfo("Pattern manager node started")
    pmn.cb_iterate(TriggerRequest())

    r = rospy.Rate(5)
    while not rospy.is_shutdown():
        pmn.pub_markers()
        pmn.pub_current_tf()
        r.sleep()
